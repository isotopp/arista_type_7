#!/usr/bin/env ruby

# reimplementation of https://github.com/isotopp/arista_type_7
require 'base64'
require 'openssl'

SEED = [0xd5, 0xa8, 0xc9, 0x1e, 0xf5, 0xd5, 0x8a, 0x23].freeze

PARITY_BITS = [
    0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x07, 0x07,
    0x08, 0x08, 0x0b, 0x0b, 0x0d, 0x0d, 0x0e, 0x0e,
    0x10, 0x10, 0x13, 0x13, 0x15, 0x15, 0x16, 0x16,
    0x19, 0x19, 0x1a, 0x1a, 0x1c, 0x1c, 0x1f, 0x1f,
    0x20, 0x20, 0x23, 0x23, 0x25, 0x25, 0x26, 0x26,
    0x29, 0x29, 0x2a, 0x2a, 0x2c, 0x2c, 0x2f, 0x2f,
    0x31, 0x31, 0x32, 0x32, 0x34, 0x34, 0x37, 0x37,
    0x38, 0x38, 0x3b, 0x3b, 0x3d, 0x3d, 0x3e, 0x3e,
    0x40, 0x40, 0x43, 0x43, 0x45, 0x45, 0x46, 0x46,
    0x49, 0x49, 0x4a, 0x4a, 0x4c, 0x4c, 0x4f, 0x4f,
    0x51, 0x51, 0x52, 0x52, 0x54, 0x54, 0x57, 0x57,
    0x58, 0x58, 0x5b, 0x5b, 0x5d, 0x5d, 0x5e, 0x5e,
    0x61, 0x61, 0x62, 0x62, 0x64, 0x64, 0x67, 0x67,
    0x68, 0x68, 0x6b, 0x6b, 0x6d, 0x6d, 0x6e, 0x6e,
    0x70, 0x70, 0x73, 0x73, 0x75, 0x75, 0x76, 0x76,
    0x79, 0x79, 0x7a, 0x7a, 0x7c, 0x7c, 0x7f, 0x7f
].freeze

def des_setparity(key)
   key.map { |b| PARITY_BITS[b & 0x7f] }.map(&:chr).join('')
end

def hashkey(pw)
   key = SEED.dup
   pw.split('').each_with_index { |b, i| key[i & 7] ^= b.ord }
   des_setparity(key)
end

def cbc_encrypt(key:, data:)
   cipher = OpenSSL::Cipher::DES.new(:cbc).encrypt
   cipher.key = hashkey(key)
   cipher.iv = "\x00" * 8
   cipher.padding = 0
   padlen = 8 - (data.length + 4) % 8
   ciphertext = "\x4c\x88\xbb".force_encoding('ASCII-8BIT') + ((padlen << 4) + 0xe).chr + data + "\x00" * padlen
   cipher.update(ciphertext) + cipher.final
end

def cbc_decrypt(key:, data:)
   cipher = OpenSSL::Cipher::DES.new(:cbc).decrypt
   cipher.key = hashkey(key)
   cipher.iv = "\x00" * 8
   cipher.padding = 0
   result = cipher.update(data) + cipher.final
   result[4...(result.length - (result[3].ord >> 4))]
end

def encrypt(key:, data:)
   Base64.strict_encode64(cbc_encrypt(key: key, data: data))
end

def decrypt(key:, data:)
   cbc_decrypt(key: key, data: Base64.decode64(data))
end
